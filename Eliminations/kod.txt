let radius = 5;

function setup(){
  createCanvas(400,400);
  background(0);
  pole_calkowite(radius, [100,0,100]);
}

function draw(){
  fill(0,255,0);//pkt pomocnicze
  circle(50,50,radius); 
  circle(340,250,radius);
  circle(150,90,radius);
  circle(70,370,radius);
  
}

function pole_calkowite(radius_, color_){
  let trj1 = [[50,50], //wierzcholek najbardziej na lewo     OBOWIAZKOWO
            [150, 90], //wierzcholek w srodku
            [340,250]]; //wierzcholek najbardziej na prawo
  
  //if wierzcholek w srodku jest powyzej odcinka wierzcholka z lewj i z prawej to gora true
  //if ponizej gora false
  pole(trj1, radius_, gora = true,  color_);
  
  let trj2 = [[50,50], //wierzcholek trojkata     OBOWIAZKOWO
            [70,370], //wierzcholek trojkata
            [340,250]]; //wierzcholek trojkata
  
  pole(trj2, radius_, gora = false, color_);
}
//Rysujesz pole 1 trojkata 
function pole(pkty, radius_, gora, color__){
  let wsp_x = min_max_wsp(pkty)[0];  //tworzymy kwadrat opisany na trojkacie
  let wsp_y = min_max_wsp(pkty)[1];
  
  print(wsp_x);
  print(wsp_y);
  
  let xowe = seq(wsp_x[0],wsp_x[1], radius_);
  let yowe = seq(wsp_y[0],wsp_y[1], radius_);
  
  for(let i = 0; i < xowe.length; i++){
    for(let j = 0; j < yowe.length; j++){
      
      if(gora){
      if(linear(xowe[i], [pkty[0],pkty[1]]) < yowe[j] && 
         linear(xowe[i], [pkty[1],pkty[2]]) < yowe[j] &&
         linear(xowe[i], [pkty[2],pkty[0]]) > yowe[j]){
        kolko(xowe[i], yowe[j], color_ = color__, radius_);  
      }
      }
      if(!gora){
      if(linear(xowe[i], [pkty[0],pkty[1]]) > yowe[j] &&
         linear(xowe[i], [pkty[1],pkty[2]]) > yowe[j] && 
         linear(xowe[i], [pkty[2],pkty[0]]) < yowe[j]){
        kolko(xowe[i], yowe[j], color_ = color__, radius_);  
      }
      }
    }
  }
}
  
function kolko(x, y, color_, radius_){
    fill(color_);
    circle(x,y,radius);
}

function seq(start, stop, step){
  let array = [];
  let i = 0;
  while(step*i + start < stop){
        array[i] = step*i + start;
        i++;
  }
  if(step*i + start == stop){
    array[i] = stop;
  }
  return array;
}

function min_max_wsp(wektor_pkt){
  let min_max_x = [wektor_pkt[0][0], wektor_pkt[0][0]];
  let min_max_y = [wektor_pkt[0][1], wektor_pkt[0][1]];
  let liczba_iter = wektor_pkt.length;
  
  for(let i = 0; i < liczba_iter; i++){
    if(min_max_x[0] > wektor_pkt[i][0]){//min x
      min_max_x[0] = wektor_pkt[i][0];
    }
    
    if(min_max_y[0] > wektor_pkt[i][1]){//min y
      min_max_y[0] = wektor_pkt[i][1];
    }
    
    if(min_max_x[1] < wektor_pkt[i][0]){//max x
      min_max_x[1] = wektor_pkt[i][0];
    }
    
    if(min_max_y[1] < wektor_pkt[i][1]){//max y
      min_max_y[1] = wektor_pkt[i][1];
    }
  }
  
  return [min_max_x,min_max_y];
}

function linear(x, pkty){
  if(!(pkty[1][0] == pkty[0][0] || pkty[1][1] == pkty[0][1])){
  let a = (pkty[0][1]-pkty[1][1])/(pkty[0][0]-pkty[1][0]);
  let b = pkty[0][1] -a * pkty[0][0];
  //print(round(a*x + b));
  return round(a*x + b);}
  
  if(pkty[1][0] == pkty[0][0]){ // x = const
    return round(pkty[1][0]);
  }
  
  if(pkty[1][1] == pkty[0][1]){// y = const
    return round(pkty[0][1]);
  }
}